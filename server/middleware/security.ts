/**
 * Security Middleware
 * 
 * Rate limiting, security headers, and CORS configuration.
 * These are critical for production security.
 */

import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { Request, Response, NextFunction } from 'express';
import { config } from '../config';
import { createLogger } from '../lib/logger';

const logger = createLogger('security');

// ============================================
// RATE LIMITING
// ============================================

/**
 * General API rate limiter
 * 100 requests per minute per IP
 */
export const generalRateLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 100, // 100 requests per minute
  message: {
    error: 'Too many requests',
    message: 'Please try again in a minute',
    retryAfter: 60,
  },
  standardHeaders: true, // Return rate limit info in headers
  legacyHeaders: false, // Disable X-RateLimit-* headers
  handler: (req: Request, res: Response) => {
    logger.warn({ 
      ip: req.ip, 
      path: req.path,
      method: req.method 
    }, 'Rate limit exceeded');
    
    res.status(429).json({
      error: 'Too many requests',
      message: 'Please try again in a minute',
      retryAfter: 60,
    });
  },
});

/**
 * Strict rate limiter for authentication endpoints
 * 20 requests per minute per IP (prevents brute force)
 */
export const authRateLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 20, // 20 requests per minute
  message: {
    error: 'Too many authentication attempts',
    message: 'Please try again in a minute',
    retryAfter: 60,
  },
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req: Request, res: Response) => {
    logger.warn({ 
      ip: req.ip, 
      path: req.path,
      email: req.body?.email ? `${req.body.email.substring(0, 3)}***` : undefined
    }, 'Auth rate limit exceeded');
    
    res.status(429).json({
      error: 'Too many authentication attempts',
      message: 'Please try again in a minute',
      retryAfter: 60,
    });
  },
});

/**
 * Very strict rate limiter for sensitive operations
 * 5 requests per minute (password reset, verification resend)
 */
export const sensitiveRateLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 5, // 5 requests per minute
  message: {
    error: 'Too many attempts',
    message: 'Please wait before trying again',
    retryAfter: 60,
  },
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req: Request, res: Response) => {
    logger.warn({ 
      ip: req.ip, 
      path: req.path 
    }, 'Sensitive operation rate limit exceeded');
    
    res.status(429).json({
      error: 'Too many attempts',
      message: 'Please wait before trying again',
      retryAfter: 60,
    });
  },
});

// ============================================
// SECURITY HEADERS (Helmet)
// ============================================

/**
 * Security headers middleware using Helmet
 * Protects against common web vulnerabilities
 */
export const securityHeaders = helmet({
  // Content Security Policy
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"], // Needed for Vite dev
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: [
        "'self'",
        "http://localhost:*",
        "ws://localhost:*",
        "http://localhost:4319", // OTEL collector
        "http://localhost:16686", // Jaeger
      ],
    },
  },
  // Prevent clickjacking
  frameguard: { action: 'deny' },
  // Hide X-Powered-By header
  hidePoweredBy: true,
  // Prevent MIME sniffing
  noSniff: true,
  // XSS protection
  xssFilter: true,
  // Referrer policy
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
});

// ============================================
// CORS CONFIGURATION
// ============================================

/**
 * CORS middleware with environment-specific origins
 */
export function corsMiddleware(req: Request, res: Response, next: NextFunction) {
  const allowedOrigins = config.env === 'production'
    ? [
        // Production: only allow specific domains
        'https://krystaline.io',
        'https://www.krystaline.io',
        'https://app.krystaline.io',
      ]
    : [
        // Development: allow localhost variants
        'http://localhost:5173',
        'http://localhost:5000',
        'http://127.0.0.1:5173',
        'http://127.0.0.1:5000',
      ];

  const origin = req.headers.origin;
  
  // Check if origin is allowed
  if (origin && allowedOrigins.includes(origin)) {
    res.header('Access-Control-Allow-Origin', origin);
  } else if (config.env !== 'production') {
    // In development, be more permissive but still log unknown origins
    res.header('Access-Control-Allow-Origin', origin || '*');
    if (origin && !allowedOrigins.includes(origin)) {
      logger.debug({ origin }, 'CORS: Unknown origin in development mode');
    }
  }
  // In production, if origin not in list, no CORS header is set (request blocked)

  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, x-trace-id, x-span-id, traceparent');
  res.header('Access-Control-Allow-Credentials', 'true');
  res.header('Access-Control-Max-Age', '86400'); // 24 hours preflight cache

  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
}

// ============================================
// REQUEST TIMEOUT
// ============================================

/**
 * Request timeout middleware
 * Prevents long-running requests from hanging
 */
export function requestTimeout(timeoutMs: number = 30000) {
  return (req: Request, res: Response, next: NextFunction) => {
    res.setTimeout(timeoutMs, () => {
      logger.warn({
        path: req.path,
        method: req.method,
        ip: req.ip,
        timeoutMs,
      }, 'Request timeout');
      
      if (!res.headersSent) {
        res.status(408).json({
          error: 'Request Timeout',
          message: `Request took longer than ${timeoutMs / 1000} seconds`,
        });
      }
    });
    next();
  };
}
