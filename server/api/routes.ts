// Clean API Routes - Crypto Exchange
// Multi-user with BTC transfers

import type { Express } from "express";
import { Request, Response } from "express";
import { z } from "zod";
import { fromZodError } from "zod-validation-error";
import { orderService, getPrice } from "../core/order-service";
import { insertOrderSchema, insertTransferSchema } from "@shared/schema";
import { traces } from "../otel";
import { createLogger } from "../lib/logger";
import { getErrorMessage } from "../lib/errors";
import db from "../db";
import authRoutes from "./auth-routes";
import twoFactorRoutes from "./2fa-routes";

const logger = createLogger('api-routes');

export function registerRoutes(app: Express) {
  logger.info('Registering API routes');

  // Register auth routes (profile, sessions, password management)
  app.use('/api/auth', authRoutes);

  // Register 2FA routes
  app.use('/api/auth/2fa', twoFactorRoutes);
  // ============================================

  // Get all verified users (for transfers)
  app.get("/api/users", async (req: Request, res: Response) => {
    try {
      // Get real users from database (only verified ones)
      const result = await db.query(
        `SELECT id, email, status FROM users WHERE status = 'verified' ORDER BY created_at DESC LIMIT 50`
      );

      // Map to expected format for transfer form
      const users = result.rows.map(user => ({
        id: user.id,
        name: user.email.split('@')[0], // Use username part of email
        email: user.email,
        avatar: 'ðŸ‘¤'
      }));

      res.json(users);
    } catch (error: unknown) {
      logger.error({ error: getErrorMessage(error) }, 'Failed to fetch users');
      res.status(500).json({ error: "Failed to fetch users" });
    }
  });

  // ============================================
  // WALLET & PRICE ENDPOINTS
  // ============================================

  // Get current BTC price (real from Binance)
  app.get("/api/price", async (req: Request, res: Response) => {
    try {
      // Import priceService for real Binance prices
      const { priceService } = await import('../services/price-service');

      // Try to get real BTC price from Binance
      const btcPrice = priceService.getPrice('BTC');
      const ethPrice = priceService.getPrice('ETH');
      const status = priceService.getStatus();

      if (btcPrice) {
        // Return real Binance price
        res.json({
          pair: "BTC/USD",
          price: btcPrice.price,
          BTC: btcPrice.price,
          ETH: ethPrice?.price || 0,
          change24h: 0, // Binance mini ticker doesn't include 24h change
          timestamp: btcPrice.timestamp,
          source: btcPrice.source,
          connected: status.connected
        });
      } else {
        // No price available - do NOT return fake prices
        res.json({
          pair: "BTC/USD",
          price: null,
          BTC: null,
          ETH: null,
          change24h: 0,
          timestamp: new Date(),
          source: 'none',
          connected: false,
          available: false,
          message: 'Waiting for pricing feed...'
        });
      }
    } catch (error: unknown) {
      res.status(500).json({ error: "Failed to fetch price" });
    }
  });

  // Get wallet balance for a user (default: seed.user.primary@krystaline.io)
  app.get("/api/wallet", async (req: Request, res: Response) => {
    try {
      const userId = (req.query.userId as string) || 'seed.user.primary@krystaline.io';
      const wallet = await orderService.getWallet(userId);
      if (!wallet) {
        return res.status(404).json({ error: "User not found" });
      }
      const price = getPrice();
      res.json({
        ...wallet,
        btcValue: wallet.btc * price,
        totalValue: wallet.usd + (wallet.btc * price)
      });
    } catch (error: unknown) {
      res.status(500).json({ error: "Failed to fetch wallet" });
    }
  });

  // Get wallet for specific user
  app.get("/api/wallet/:userId", async (req: Request, res: Response) => {
    try {
      const { userId } = req.params;
      const wallet = await orderService.getWallet(userId);
      if (!wallet) {
        return res.status(404).json({ error: "User not found" });
      }
      const price = getPrice();
      res.json({
        ...wallet,
        btcValue: wallet.btc * price,
        totalValue: wallet.usd + (wallet.btc * price)
      });
    } catch (error: unknown) {
      res.status(500).json({ error: "Failed to fetch wallet" });
    }
  });

  // ============================================
  // ORDER ENDPOINTS
  // ============================================

  // Submit trade order
  app.post("/api/orders", async (req: Request, res: Response) => {
    try {
      const incomingTraceparent = req.headers['traceparent'];
      if (incomingTraceparent) {
        logger.debug({ traceparent: incomingTraceparent }, 'Incoming trace context from client');
      }

      // Extend schema to include userId
      const orderWithUserSchema = insertOrderSchema.extend({
        userId: z.string().optional()
      });

      const validation = orderWithUserSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          error: "Invalid order request",
          details: fromZodError(validation.error).message
        });
      }

      const orderData = validation.data;

      const result = await orderService.submitOrder({
        userId: orderData.userId || 'seed.user.primary@krystaline.io',
        pair: orderData.pair,
        side: orderData.side,
        quantity: orderData.quantity,
        orderType: orderData.orderType
      });

      const wallet = await orderService.getWallet(orderData.userId || 'seed.user.primary@krystaline.io');

      res.json({
        success: true,
        orderId: result.orderId,
        order: {
          orderId: result.orderId,
          pair: orderData.pair,
          side: orderData.side,
          quantity: orderData.quantity
        },
        execution: result.execution,
        wallet,
        traceId: result.traceId,
        spanId: result.spanId
      });

    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      logger.error({ err: error }, 'Order processing failed');
      res.status(500).json({ error: "Failed to process order", details: errorMessage });
    }
  });

  // Get orders
  app.get("/api/orders", async (req: Request, res: Response) => {
    try {
      const orders = await orderService.getOrders(10);
      res.json(orders);
    } catch (error: unknown) {
      res.status(500).json({ error: "Failed to fetch orders" });
    }
  });

  // ============================================
  // TRANSFER ENDPOINTS
  // ============================================

  // Transfer BTC between users
  app.post("/api/transfer", async (req: Request, res: Response) => {
    try {
      const incomingTraceparent = req.headers['traceparent'];
      if (incomingTraceparent) {
        logger.debug({ traceparent: incomingTraceparent }, 'Incoming trace context for transfer');
      }

      const validation = insertTransferSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          error: "Invalid transfer request",
          details: fromZodError(validation.error).message
        });
      }

      const transferData = validation.data;

      // fromUserId and toUserId are optional - provide defaults if needed
      const fromUserId = transferData.fromUserId || 'unknown';
      const toUserId = transferData.toUserId || 'unknown';

      const result = await orderService.processTransfer({
        fromUserId,
        toUserId,
        amount: transferData.amount
      });

      // Get updated wallets
      const fromWallet = await orderService.getWallet(fromUserId);
      const toWallet = await orderService.getWallet(toUserId);

      res.json({
        success: result.status === 'COMPLETED',
        transferId: result.transferId,
        transfer: result.transfer,
        status: result.status,
        message: result.message,
        wallets: {
          [fromUserId]: fromWallet,
          [toUserId]: toWallet
        },
        traceId: result.traceId,
        spanId: result.spanId
      });

    } catch (error: unknown) {
      logger.error({ err: error }, 'Transfer processing failed');
      res.status(500).json({ error: "Failed to process transfer" });
    }
  });

  // Get transfers
  app.get("/api/transfers", async (req: Request, res: Response) => {
    try {
      const transfers = await orderService.getTransfers(10);
      res.json(transfers);
    } catch (error: unknown) {
      res.status(500).json({ error: "Failed to fetch transfers" });
    }
  });

  // ============================================
  // LEGACY PAYMENT ROUTES (backwards compat)
  // ============================================

  app.post("/api/payments", async (req: Request, res: Response) => {
    const orderRequest = {
      userId: 'seed.user.primary@krystaline.io',
      pair: "BTC/USD" as const,
      side: "BUY" as const,
      quantity: (req.body.amount || 100) / getPrice(),
      orderType: "MARKET" as const
    };

    try {
      const result = await orderService.submitOrder(orderRequest);
      const wallet = await orderService.getWallet('seed.user.primary@krystaline.io');

      res.json({
        success: true,
        payment: {
          id: result.orderId,
          amount: req.body.amount || 100,
          currency: "USD",
          status: result.execution?.status || "PENDING"
        },
        traceId: result.traceId,
        processorResponse: result.execution ? {
          status: result.execution.status,
          processedAt: result.execution.processedAt,
          processorId: result.execution.processorId
        } : undefined
      });
    } catch (error: unknown) {
      res.status(500).json({ error: "Failed to process payment" });
    }
  });

  app.get("/api/payments", async (req: Request, res: Response) => {
    try {
      const orders = await orderService.getOrders(10);
      res.json(orders);
    } catch (error: unknown) {
      res.status(500).json({ error: "Failed to fetch payments" });
    }
  });

  // ============================================
  // TRACES ENDPOINT (for UI)
  // ============================================

  app.get("/api/traces", async (req: Request, res: Response) => {
    try {
      const traceGroups = new Map<string, any[]>();

      traces.forEach(span => {
        const traceId = span.traceId;
        if (!traceGroups.has(traceId)) {
          traceGroups.set(traceId, []);
        }
        traceGroups.get(traceId)?.push(span);
      });

      const formattedTraces = Array.from(traceGroups.entries()).map(([traceId, spans]) => {
        const rootSpan = spans.find(s => !s.parentSpanId) || spans[0];
        return {
          traceId,
          rootSpanId: rootSpan?.spanId || spans[0]?.spanId,
          status: 'completed',
          duration: Math.max(...spans.map(s => s.duration || 0)),
          startTime: new Date(Math.min(...spans.map(s => new Date(s.startTime).getTime()))),
          spans: spans.map(span => ({
            spanId: span.spanId,
            parentSpanId: span.parentSpanId,
            traceId: span.traceId,
            operationName: getOperationName(span),
            serviceName: getServiceName(span),
            duration: span.duration,
            startTime: span.startTime,
            endTime: span.endTime,
            tags: span.attributes || {},
            status: 'completed'
          }))
        };
      });

      formattedTraces.sort((a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime());
      res.json(formattedTraces.slice(0, 10));
    } catch (error: unknown) {
      res.status(500).json({ error: "Failed to fetch traces" });
    }
  });

  // Clear all data
  app.delete("/api/clear", async (req: Request, res: Response) => {
    try {
      const { clearTraces } = await import('../otel');
      await orderService.clearAllData();
      clearTraces();
      res.json({ success: true, message: "All data cleared" });
    } catch (error: unknown) {
      res.status(500).json({ error: "Failed to clear data" });
    }
  });
}

// Helper functions
function getOperationName(span: any): string {
  const httpMethod = span.attributes?.['http.method'];
  const httpTarget = span.attributes?.['http.target'];
  const messagingOperation = span.attributes?.['messaging.operation'];
  const messagingSystem = span.attributes?.['messaging.system'];

  if (messagingSystem === 'rabbitmq') {
    return messagingOperation === 'publish' ? 'order.submit' : 'order.match';
  }

  if (httpMethod && httpTarget) {
    if (httpTarget.includes('/orders')) return 'order.submit';
    if (httpTarget.includes('/transfer')) return 'btc.transfer';
    return `${httpMethod.toLowerCase()}.${httpTarget.replace('/api/', '')}`;
  }

  return span.name || 'unknown';
}

function getServiceName(span: any): string {
  const serviceName = span.serviceName || span.attributes?.['service.name'];
  const httpUrl = span.attributes?.['http.url'];
  const messagingSystem = span.attributes?.['messaging.system'];

  if (messagingSystem === 'rabbitmq') return 'rabbitmq';
  if (httpUrl?.includes(':8000')) return 'kong-gateway';
  return serviceName || 'kx-exchange';
}